
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ë°”ë‹¤ë”°ë¼ - í•´ì•ˆë„ë¡œ ê°ì„± ê¸¸ì°¾ê¸°</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v7.3.0/ol.css">
  <script src="https://cdn.jsdelivr.net/npm/ol@v7.3.0/dist/ol.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #top-bar { padding: 10px; background: #0077cc; color: white; display: flex; flex-direction: column; gap: 8px; }
    #inputs { display: flex; gap: 8px; }
    input { padding: 8px; width: 240px; }
    button { padding: 8px 16px; background: white; border: none; cursor: pointer; }
    #map { width: 100%; height: calc(100vh - 100px); }
  </style>
</head>
<body>
  <div id="top-bar">
    <div><b>ğŸš— ë°”ë‹¤ë”°ë¼ - í•´ì•ˆë„ë¡œ ê°ì„± ê¸¸ì°¾ê¸°</b></div>
    <div id="inputs">
      <input id="start" type="text" placeholder="ì¶œë°œì§€ ì£¼ì†Œ ë˜ëŠ” ì¥ì†Œëª…">
      <input id="end" type="text" placeholder="ë„ì°©ì§€ ì£¼ì†Œ ë˜ëŠ” ì¥ì†Œëª…">
      <button onclick="searchRoute()">ê²½ë¡œ ê²€ìƒ‰</button>
    </div>
  </div>
  <div id="map"></div>
  <script>
    const map = new ol.Map({
      target: 'map',
      layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ],
      view: new ol.View({ center: ol.proj.fromLonLat([127.5, 36.5]), zoom: 7 })
    });
    let routeLayer;

    function clearLayers() {
      if (routeLayer) map.removeLayer(routeLayer);
    }

    async function geocode(address) {
      const key = "FA346133-805B-3BB4-B8C2-372973E3A4ED";
      const url1 = `https://api.vworld.kr/req/address?service=address&request=getcoord&format=json&type=road&address=${encodeURIComponent(address)}&key=${key}`;
      const res1 = await fetch(url1);
      const json1 = await res1.json();
      if (json1.response.result) {
        const point = json1.response.result.point;
        const coord = [parseFloat(point.x), parseFloat(point.y)];
        console.log("ì£¼ì†Œê²€ìƒ‰ ì„±ê³µ:", address, coord);
        return coord;
      }

      const url2 = `https://api.vworld.kr/req/search?service=search&request=search&format=json&query=${encodeURIComponent(address)}&key=${key}`;
      const res2 = await fetch(url2);
      const json2 = await res2.json();
      const items = json2.response?.result?.items || [];
      for (const item of items) {
        if (item.point) {
          const coord = [parseFloat(item.point.x), parseFloat(item.point.y)];
          console.log("ì¥ì†Œëª… ê²€ìƒ‰ ì„±ê³µ:", address, coord);
          return coord;
        }
      }
      console.warn("ê²€ìƒ‰ ì‹¤íŒ¨:", address);
      return null;
    }

    async function fetchCoastline() {
      const res = await fetch("https://rpwjd99.github.io/coastal-drive/í•´ì•ˆì„ _êµ­ê°€ê¸°ë³¸ë„.geojson");
      return await res.json();
    }

    async function tryORS(start, waypoint, end) {
      const apiKey = "5b3ce3597851110001cf62486d543846e80049df9c7a9e10ecef2953";
      try {
        const res = await fetch("https://api.openrouteservice.org/v2/directions/driving-car/geojson", {
          method: "POST",
          headers: {
            "Authorization": apiKey,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ coordinates: [start, waypoint, end] })
        });
        return res.ok ? await res.json() : null;
      } catch {
        return null;
      }
    }

    function getDistance(a, b) {
      return Math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2);
    }

    async function findValidWaypoint(start, end, coastGeoJSON) {
      const startLat = start[1], startLon = start[0];
      const candidates = coastGeoJSON.features.map(f => f.geometry.coordinates).filter(coord => {
        const [lon, lat] = coord;
        return Math.abs(lat - startLat) < 0.1 || Math.abs(lon - startLon) < 0.1;
      }).sort((a, b) => getDistance(start, a) - getDistance(start, b));

      for (const radius of [0.03, 0.05]) {
        for (const wp of candidates) {
          if (getDistance(start, wp) < radius) {
            const route = await tryORS(start, wp, end);
            if (route) return { wp, route };
          }
        }
      }
      return null;
    }

    async function searchRoute() {
      clearLayers();
      const startText = document.getElementById("start").value;
      const endText = document.getElementById("end").value;
      const start = await geocode(startText);
      const end = await geocode(endText);
      if (!start || !end) return alert("ì¶œë°œì§€ ë˜ëŠ” ë„ì°©ì§€ ì£¼ì†Œ/ì¥ì†Œëª…ì„ ì •í™•íˆ ì…ë ¥í•´ ì£¼ì„¸ìš”.");

      const coast = await fetchCoastline();
      const result = await findValidWaypoint(start, end, coast);
      if (!result) return alert("ë„ë¡œ ì—°ê²° ê°€ëŠ¥í•œ í•´ì•ˆ ìš°íšŒ ê²½ìœ ì§€ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");

      const features = new ol.format.GeoJSON().readFeatures(result.route, { featureProjection: 'EPSG:3857' });
      routeLayer = new ol.layer.Vector({
        source: new ol.source.Vector({ features }),
        style: new ol.style.Style({ stroke: new ol.style.Stroke({ color: '#0077cc', width: 4 }) })
      });
      map.addLayer(routeLayer);
      map.getView().fit(routeLayer.getSource().getExtent(), { padding: [50,50,50,50] });
    }
  </script>
</body>
</html>
