
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>바다따라 - 해안도로 감성 길찾기</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v7.3.0/ol.css">
  <script src="https://cdn.jsdelivr.net/npm/ol@v7.3.0/dist/ol.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #top-bar { padding: 10px; background: #0077cc; color: white; display: flex; flex-direction: column; gap: 8px; }
    #inputs { display: flex; gap: 8px; }
    input { padding: 8px; width: 240px; }
    button { padding: 8px 16px; background: white; border: none; cursor: pointer; }
    #map { width: 100%; height: calc(100vh - 100px); }
    .autocomplete-suggestions {
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      z-index: 10;
      max-height: 150px;
      overflow-y: auto;
    }
    .autocomplete-suggestions div {
      padding: 6px;
      cursor: pointer;
    }
    .autocomplete-suggestions div:hover {
      background-color: #efefef;
    }
  </style>
</head>
<body>
  <div id="top-bar">
    <div><b>🚗 바다따라 - 해안도로 감성 길찾기</b></div>
    <div id="inputs">
      <div style="position:relative;">
        <input id="start" type="text" placeholder="출발지 검색">
        <div id="suggest-start" class="autocomplete-suggestions"></div>
      </div>
      <div style="position:relative;">
        <input id="end" type="text" placeholder="도착지 검색">
        <div id="suggest-end" class="autocomplete-suggestions"></div>
      </div>
      <button onclick="searchRoute()">경로 검색</button>
    </div>
  </div>
  <div id="map"></div>
  <script>
    const map = new ol.Map({
      target: 'map',
      layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ],
      view: new ol.View({ center: ol.proj.fromLonLat([127.5, 36.5]), zoom: 7 })
    });
    let routeLayer;

    function clearLayers() {
      if (routeLayer) map.removeLayer(routeLayer);
    }

    async function autocomplete(inputId, suggestId) {
      const input = document.getElementById(inputId);
      const suggestBox = document.getElementById(suggestId);
      input.addEventListener("input", async () => {
        const text = input.value.trim();
        if (text.length < 2) return suggestBox.innerHTML = "";
        const key = "FA346133-805B-3BB4-B8C2-372973E3A4ED";
        const url = `https://api.vworld.kr/req/search?service=search&request=autocomplete&query=${encodeURIComponent(text)}&key=${key}`;
        const res = await fetch(url);
        const json = await res.json();
        const items = json.response.result.items;
        suggestBox.innerHTML = items.map(i => `<div>${i.title}</div>`).join("");
        suggestBox.querySelectorAll("div").forEach(div => {
          div.onclick = () => {
            input.value = div.innerText;
            suggestBox.innerHTML = "";
          };
        });
      });
    }

    autocomplete("start", "suggest-start");
    autocomplete("end", "suggest-end");

    async function geocode(address) {
      const key = "FA346133-805B-3BB4-B8C2-372973E3A4ED";
      let url = `https://api.vworld.kr/req/address?service=address&request=getcoord&format=json&type=road&address=${encodeURIComponent(address)}&key=${key}`;
      let res = await fetch(url);
      let json = await res.json();
      let point = json.response.result?.point;
      if (point) return [parseFloat(point.x), parseFloat(point.y)];

      // fallback: POI 검색
      url = `https://api.vworld.kr/req/search?service=search&request=search&format=json&query=${encodeURIComponent(address)}&key=${key}`;
      res = await fetch(url);
      json = await res.json();
      const item = json.response.result.items?.[0];
      return item ? [parseFloat(item.point.x), parseFloat(item.point.y)] : null;
    }

    async function fetchCoastline() {
      const res = await fetch("https://rpwjd99.github.io/coastal-drive/해안선_국가기본도.geojson");
      return await res.json();
    }

    async function tryORS(start, waypoint, end) {
      const apiKey = "5b3ce3597851110001cf62486d543846e80049df9c7a9e10ecef2953";
      try {
        const res = await fetch("https://api.openrouteservice.org/v2/directions/driving-car/geojson", {
          method: "POST",
          headers: {
            "Authorization": apiKey,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ coordinates: [start, waypoint, end] })
        });
        return res.ok ? await res.json() : null;
      } catch {
        return null;
      }
    }

    function getDistance(a, b) {
      return Math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2);
    }

    async function findValidWaypoint(start, end, coastGeoJSON) {
      const startLat = start[1], startLon = start[0];
      const candidates = coastGeoJSON.features.map(f => f.geometry.coordinates).filter(coord => {
        const [lon, lat] = coord;
        return Math.abs(lat - startLat) < 0.1 || Math.abs(lon - startLon) < 0.1;
      }).sort((a, b) => getDistance(start, a) - getDistance(start, b));

      for (const radius of [0.03, 0.05]) { // 3km, 5km (약도 단위)
        for (const wp of candidates) {
          if (getDistance(start, wp) < radius) {
            const route = await tryORS(start, wp, end);
            if (route) return { wp, route };
          }
        }
      }
      return null;
    }

    async function searchRoute() {
      clearLayers();
      const startText = document.getElementById("start").value;
      const endText = document.getElementById("end").value;
      const start = await geocode(startText);
      const end = await geocode(endText);
      if (!start || !end) return alert("정확한 주소 또는 장소명을 입력하세요.");

      const coast = await fetchCoastline();
      const result = await findValidWaypoint(start, end, coast);
      if (!result) return alert("도로 연결 가능한 해안 우회 경유지를 찾지 못했습니다.");

      const features = new ol.format.GeoJSON().readFeatures(result.route, { featureProjection: 'EPSG:3857' });
      routeLayer = new ol.layer.Vector({
        source: new ol.source.Vector({ features }),
        style: new ol.style.Style({ stroke: new ol.style.Stroke({ color: '#0077cc', width: 4 }) })
      });
      map.addLayer(routeLayer);
      map.getView().fit(routeLayer.getSource().getExtent(), { padding: [50,50,50,50] });
    }
  </script>
</body>
</html>
